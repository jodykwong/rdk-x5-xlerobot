#!/usr/bin/env python3.10
"""
AudioRecorderManager - ç»Ÿä¸€éŸ³é¢‘å½•éŸ³å™¨ç®¡ç†å™¨
=====================================

è§£å†³ASRç³»ç»Ÿä¸­å½•éŸ³å™¨çš„å¹¶å‘è®¿é—®å’ŒçŠ¶æ€ç®¡ç†é—®é¢˜ã€‚
å®ç°å•ä¾‹æ¨¡å¼ï¼Œç¡®ä¿å…¨å±€åªæœ‰ä¸€ä¸ªå½•éŸ³å™¨å®ä¾‹ã€‚

ä½œè€…: Claude Code Agent
æ—¥æœŸ: 2025-11-18
"""

import threading
import time
import logging
from typing import Optional, Dict, Any
from enum import Enum

# å¯¼å…¥å½•éŸ³å™¨å®ç°
from .simple_alsa_recorder import SimpleALSARecorder

# é…ç½®æ—¥å¿—
logger = logging.getLogger(__name__)

class RecordingState(Enum):
    """å½•éŸ³çŠ¶æ€æšä¸¾"""
    IDLE = "idle"
    BUSY = "busy"
    RECORDING = "recording"
    ERROR = "error"

class AudioRecorderManager:
    """
    éŸ³é¢‘å½•éŸ³å™¨ç®¡ç†å™¨ï¼ˆå•ä¾‹æ¨¡å¼ï¼‰

    åŠŸèƒ½ï¼š
    1. ç¡®ä¿å…¨å±€åªæœ‰ä¸€ä¸ªå½•éŸ³å™¨å®ä¾‹
    2. ç®¡ç†å½•éŸ³å™¨çš„å¹¶å‘è®¿é—®
    3. ç»Ÿä¸€å½•éŸ³å™¨é…ç½®å’ŒçŠ¶æ€ç®¡ç†
    4. æä¾›å½•éŸ³å™¨ä½¿ç”¨é˜Ÿåˆ—å’Œé”æœºåˆ¶
    """

    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        """å•ä¾‹æ¨¡å¼å®ç°"""
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(AudioRecorderManager, cls).__new__(cls)
        return cls._instance

    def __init__(self):
        """åˆå§‹åŒ–å½•éŸ³å™¨ç®¡ç†å™¨"""
        if hasattr(self, '_initialized'):
            return

        self._initialized = True
        self._recorder_lock = threading.Lock()
        self._state_lock = threading.Lock()

        # å½•éŸ³å™¨å®ä¾‹
        self._recorder: Optional[SimpleALSARecorder] = None
        self._state = RecordingState.IDLE

        # å½•éŸ³å™¨é…ç½®
        self._config = {
            'target_rate': 16000,    # ASRè¦æ±‚çš„16kHz
            'channels': 1,           # å•å£°é“
            'format': 'int16',       # 16-bitæ ¼å¼
            'device': 'plughw:0,0'   # USBè®¾å¤‡
        }

        # ç»Ÿè®¡ä¿¡æ¯
        self._stats = {
            'total_requests': 0,
            'successful_recordings': 0,
            'failed_recordings': 0,
            'concurrent_conflicts': 0,
            'last_recording_time': None,
            'average_recording_duration': 0.0
        }

        # åˆå§‹åŒ–å½•éŸ³å™¨
        self._initialize_recorder()

        logger.info("âœ… AudioRecorderManageråˆå§‹åŒ–å®Œæˆ")
        logger.info(f"ğŸ“Š å½•éŸ³å™¨é…ç½®: {self._config}")

    def _initialize_recorder(self):
        """åˆå§‹åŒ–å½•éŸ³å™¨å®ä¾‹"""
        try:
            with self._recorder_lock:
                if self._recorder is not None:
                    # æ¸…ç†ç°æœ‰å½•éŸ³å™¨
                    try:
                        self._recorder.force_stop()
                    except:
                        pass

                self._recorder = SimpleALSARecorder()
                self._set_state(RecordingState.IDLE)
                logger.info("âœ… å½•éŸ³å™¨å®ä¾‹åˆå§‹åŒ–æˆåŠŸ")

        except Exception as e:
            logger.error(f"âŒ å½•éŸ³å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
            self._set_state(RecordingState.ERROR)
            raise

    def _set_state(self, state: RecordingState):
        """è®¾ç½®å½•éŸ³å™¨çŠ¶æ€"""
        with self._state_lock:
            old_state = self._state
            self._state = state
            if old_state != state:
                logger.debug(f"ğŸ“Š å½•éŸ³å™¨çŠ¶æ€å˜æ›´: {old_state.value} â†’ {state.value}")

    def get_state(self) -> RecordingState:
        """è·å–å½“å‰çŠ¶æ€"""
        with self._state_lock:
            return self._state

    def is_available(self) -> bool:
        """æ£€æŸ¥å½•éŸ³å™¨æ˜¯å¦å¯ç”¨"""
        return self.get_state() == RecordingState.IDLE

    def wait_for_availability(self, timeout: float = 5.0) -> bool:
        """ç­‰å¾…å½•éŸ³å™¨å˜ä¸ºå¯ç”¨çŠ¶æ€"""
        start_time = time.time()

        while time.time() - start_time < timeout:
            if self.is_available():
                return True
            time.sleep(0.1)

        logger.warning(f"âš ï¸ ç­‰å¾…å½•éŸ³å™¨å¯ç”¨è¶…æ—¶ ({timeout}ç§’)")
        return False

    def start_recording(self, duration: float = 3.0) -> bool:
        """
        å¼€å§‹å½•éŸ³

        Args:
            duration: å½•åˆ¶æ—¶é•¿ï¼ˆç§’ï¼‰

        Returns:
            bool: æ˜¯å¦æˆåŠŸå¯åŠ¨å½•éŸ³
        """
        # æ›´æ–°ç»Ÿè®¡
        self._stats['total_requests'] += 1
        self._stats['last_recording_time'] = time.time()

        # æ£€æŸ¥å½•éŸ³å™¨æ˜¯å¦å¯ç”¨
        if not self.is_available():
            logger.warning("âš ï¸ å½•éŸ³å™¨å½“å‰ä¸å¯ç”¨ï¼Œç­‰å¾…é‡Šæ”¾...")
            self._stats['concurrent_conflicts'] += 1

            if not self.wait_for_availability():
                logger.error("âŒ å½•éŸ³å™¨ç­‰å¾…è¶…æ—¶ï¼Œæ— æ³•å¯åŠ¨å½•éŸ³")
                self._stats['failed_recordings'] += 1
                return False

        # å°è¯•å¯åŠ¨å½•éŸ³
        try:
            with self._recorder_lock:
                if self._recorder is None:
                    logger.error("âŒ å½•éŸ³å™¨å®ä¾‹ä¸å­˜åœ¨")
                    self._stats['failed_recordings'] += 1
                    return False

                self._set_state(RecordingState.BUSY)

                logger.info(f"ğŸ¤ å¯åŠ¨å½•éŸ³ï¼Œæ—¶é•¿: {duration}ç§’")
                success = self._recorder.start_recording(duration=duration)

                if success:
                    self._set_state(RecordingState.RECORDING)
                    logger.info("âœ… å½•éŸ³å¯åŠ¨æˆåŠŸ")
                    return True
                else:
                    logger.error("âŒ å½•éŸ³å¯åŠ¨å¤±è´¥")
                    self._set_state(RecordingState.ERROR)
                    self._stats['failed_recordings'] += 1
                    return False

        except Exception as e:
            logger.error(f"âŒ å½•éŸ³å¯åŠ¨å¼‚å¸¸: {e}")
            self._set_state(RecordingState.ERROR)
            self._stats['failed_recordings'] += 1
            return False

    def stop_recording(self) -> tuple:
        """
        åœæ­¢å½•éŸ³

        Returns:
            tuple: (success: bool, audio_data: numpy.ndarray)
        """
        try:
            with self._recorder_lock:
                if self._recorder is None:
                    logger.error("âŒ å½•éŸ³å™¨å®ä¾‹ä¸å­˜åœ¨")
                    return False, None

                if self.get_state() != RecordingState.RECORDING:
                    logger.warning("âš ï¸ å½“å‰æ²¡æœ‰å½•éŸ³åœ¨è¿›è¡Œ")
                    return False, None

                logger.info("ğŸ›‘ åœæ­¢å½•éŸ³...")
                audio_data = self._recorder.stop_recording()

                # æ›´æ–°ç»Ÿè®¡
                recording_time = time.time() - self._stats['last_recording_time']
                if len(audio_data) > 0:
                    self._stats['successful_recordings'] += 1
                    # æ›´æ–°å¹³å‡å½•éŸ³æ—¶é•¿
                    total_duration = (
                        self._stats['average_recording_duration'] *
                        (self._stats['successful_recordings'] - 1) + recording_time
                    )
                    self._stats['average_recording_duration'] = (
                        total_duration / self._stats['successful_recordings']
                    )
                    logger.info(f"âœ… å½•éŸ³å®Œæˆï¼Œæ•°æ®é•¿åº¦: {len(audio_data)} samples")
                    self._set_state(RecordingState.IDLE)
                    return True, audio_data
                else:
                    logger.warning("âš ï¸ å½•éŸ³å®Œæˆä½†æ— æ•°æ®")
                    self._stats['failed_recordings'] += 1
                    self._set_state(RecordingState.ERROR)
                    return False, None

        except Exception as e:
            logger.error(f"âŒ å½•éŸ³åœæ­¢å¼‚å¸¸: {e}")
            self._set_state(RecordingState.ERROR)
            self._stats['failed_recordings'] += 1
            return False, None

    def test_recording(self, duration: float = 2.0) -> bool:
        """
        æµ‹è¯•å½•éŸ³åŠŸèƒ½

        Args:
            duration: æµ‹è¯•å½•éŸ³æ—¶é•¿

        Returns:
            bool: æµ‹è¯•æ˜¯å¦æˆåŠŸ
        """
        logger.info(f"ğŸ§ª å¼€å§‹å½•éŸ³å™¨æµ‹è¯•ï¼Œæ—¶é•¿: {duration}ç§’")

        success = self.start_recording(duration=duration)

        if success:
            # ç­‰å¾…å½•éŸ³å®Œæˆ
            time.sleep(duration + 0.5)

            test_success, audio_data = self.stop_recording()

            if test_success and audio_data is not None and len(audio_data) > 0:
                logger.info(f"ğŸ‰ å½•éŸ³å™¨æµ‹è¯•æˆåŠŸï¼Œå½•åˆ¶æ•°æ®: {len(audio_data)} samples")
                return True
            else:
                logger.error("âŒ å½•éŸ³å™¨æµ‹è¯•å¤±è´¥ï¼šæ— æœ‰æ•ˆæ•°æ®")
                return False
        else:
            logger.error("âŒ å½•éŸ³å™¨æµ‹è¯•å¤±è´¥ï¼šå¯åŠ¨å½•éŸ³å¤±è´¥")
            return False

    def force_reset(self):
        """å¼ºåˆ¶é‡ç½®å½•éŸ³å™¨"""
        logger.warning("ğŸ”„ å¼ºåˆ¶é‡ç½®å½•éŸ³å™¨...")

        try:
            with self._recorder_lock:
                if self._recorder is not None:
                    self._recorder.force_stop()
                    self._recorder = None

                self._initialize_recorder()
                logger.info("âœ… å½•éŸ³å™¨é‡ç½®å®Œæˆ")

        except Exception as e:
            logger.error(f"âŒ å½•éŸ³å™¨é‡ç½®å¤±è´¥: {e}")

    def get_stats(self) -> Dict[str, Any]:
        """è·å–å½•éŸ³å™¨ç»Ÿè®¡ä¿¡æ¯"""
        with self._state_lock:
            stats = self._stats.copy()
            stats['current_state'] = self._state.value

            # è®¡ç®—æˆåŠŸç‡
            if stats['total_requests'] > 0:
                stats['success_rate'] = (
                    stats['successful_recordings'] / stats['total_requests']
                )
            else:
                stats['success_rate'] = 0.0

            return stats

    def get_config(self) -> Dict[str, Any]:
        """è·å–å½•éŸ³å™¨é…ç½®"""
        return self._config.copy()

# å…¨å±€å•ä¾‹å®ä¾‹
_recorder_manager = None

def get_recorder_manager() -> AudioRecorderManager:
    """è·å–å…¨å±€å½•éŸ³å™¨ç®¡ç†å™¨å®ä¾‹"""
    global _recorder_manager
    if _recorder_manager is None:
        _recorder_manager = AudioRecorderManager()
    return _recorder_manager

# å‘åå…¼å®¹çš„å‡½æ•°
def create_audio_recorder() -> AudioRecorderManager:
    """åˆ›å»ºå½•éŸ³å™¨ï¼ˆè¿”å›ç®¡ç†å™¨å®ä¾‹ï¼‰"""
    return get_recorder_manager()

# å¯¼å‡ºä¸»è¦æ¥å£
__all__ = [
    'AudioRecorderManager',
    'RecordingState',
    'get_recorder_manager',
    'create_audio_recorder'
]