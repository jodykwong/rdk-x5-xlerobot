#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Epic1 ASRç³»ç»Ÿæ ¸å¿ƒæ¨¡å—
æ•´åˆåœ¨çº¿ASRæœåŠ¡ï¼Œæ”¯æŒå”¤é†’è¯æ£€æµ‹å’Œè¯­éŸ³è¯†åˆ«
"""

import asyncio
import logging
import sys
import time
# import speech_recognition as sr  # æ›¿æ¢ä¸ºçº¿ç¨‹å®‰å…¨å½•éŸ³å™¨
from .thread_safe_audio_recorder import ThreadSafeAudioRecorder, RecordingState
import numpy as np
import wave
import tempfile
import os
import threading
from pathlib import Path
from typing import Optional, Dict, Any
from enum import Enum

# æ·»åŠ é¡¹ç›®è·¯å¾„
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

# ä½¿ç”¨WebSocket ASRæœåŠ¡ï¼ˆæ ¹æ®æ¶æ„æ–‡æ¡£è¦æ±‚ï¼‰
from modules.asr.websocket.websocket_asr_service import AliyunASRWebSocketService
from modules.asr.streaming.wake_word_detector import WakeWordDetector
# ASRæ¡¥æ¥ä¸éœ€è¦TTSåŠŸèƒ½ï¼Œæš‚æ—¶æ³¨é‡Šæ‰
# from modules.tts.engine.aliyun_tts_engine import AliyunTTSEngine

# é¿å…å¯¼å…¥LLMæ¨¡å—ä»¥ç»•è¿‡ROS2ä¾èµ–
# from modules.llm.qwen_multimodal_llm import QwenMultimodalLLM

logger = logging.getLogger(__name__)

class ASRState(Enum):
    """ASRç³»ç»ŸçŠ¶æ€æšä¸¾"""
    IDLE = "idle"                      # ç©ºé—²ï¼Œç­‰å¾…å”¤é†’è¯
    WAKE_DETECTED = "wake_detected"    # æ£€æµ‹åˆ°å”¤é†’è¯
    LISTENING_COMMAND = "listening_command"  # ç›‘å¬ç”¨æˆ·æŒ‡ä»¤
    PROCESSING = "processing"          # å¤„ç†æŒ‡ä»¤
    RESPONDING = "responding"          # æ’­æ”¾å›å¤

# å¯¼å…¥é˜¿é‡Œäº‘NLSå®˜æ–¹SDK
try:
    import sys
    sys.path.append('/home/sunrise/.local/lib/python3.10/site-packages')
    from nls.token import getToken
    OFFICIAL_SDK_AVAILABLE = True
    logger.info("âœ… é˜¿é‡Œäº‘NLSå®˜æ–¹SDKå¯ç”¨")
except ImportError as e:
    OFFICIAL_SDK_AVAILABLE = False
    logger.warning(f"âš ï¸ å®˜æ–¹SDKä¸å¯ç”¨: {e}")

    # å¤‡ç”¨ï¼šTokenç®¡ç†å™¨
    try:
        from aliyun_nls_token_manager import get_token_manager
        TOKEN_MANAGER_AVAILABLE = True
    except ImportError:
        TOKEN_MANAGER_AVAILABLE = False

class ASRSystem:
    """Epic1 ASRç³»ç»Ÿé›†æˆå™¨"""

    def __init__(self):
        self.project_root = Path("/home/sunrise/xlerobot")
        self.asr_service = None
        self.wake_detector = None
        self.tts_client = None
        self.llm_client = None
        self.is_running = False
        self.audio_input = None
        # self.recognizer = sr.Recognizer()  # å·²æ›¿æ¢ä¸ºThreadSafeAudioRecorder
        self.audio_recorder = None
        self.recording = False
        self.last_wake_time = 0
        self.wake_cooldown = 2  # å”¤é†’è¯æ£€æµ‹å†·å´æ—¶é—´ï¼ˆç§’ï¼‰
        self.conversation_history = []  # å¯¹è¯å†å²
        self.max_history_length = 10  # æœ€å¤§å†å²è®°å½•æ•°

        # çŠ¶æ€æœºç®¡ç†
        self.state = ASRState.IDLE

        # æ–°å¢ï¼šç»“æœå›è°ƒå‡½æ•° - ç”¨äºROS2æ¡¥æ¥
        self.result_callback = None  # æ·»åŠ æ­¤è¡Œ

        # åˆå§‹åŒ–çŠ¶æ€
        self.initialized = False
        self.audio_configured = False

        # ä¼˜åŒ–éŸ³é¢‘å‚æ•°é…ç½®ï¼ˆåŸºäºThreadSafeAudioRecorderï¼‰
        self._configure_audio_parameters()

    def _configure_audio_parameters(self):
        """é…ç½®ä¼˜åŒ–éŸ³é¢‘å‚æ•°ï¼ˆåŸºäºThreadSafeAudioRecorderï¼‰"""
        try:
            # ThreadSafeAudioRecorderä¸éœ€è¦é¢å¤–çš„éŸ³é¢‘å‚æ•°é…ç½®
            # éŸ³é¢‘å‚æ•°åœ¨ThreadSafeAudioRecorderå†…éƒ¨å·²ç»ä¼˜åŒ–
            self.audio_configured = True

            logger.info("âœ… éŸ³é¢‘å‚æ•°é…ç½®å®Œæˆ - ThreadSafeAudioRecorderå†…ç½®ä¼˜åŒ–")
            logger.debug("ğŸ“Š éŸ³é¢‘å‚æ•°: 16kHz, å•å£°é“, 16-bit, çº¿ç¨‹å®‰å…¨")

        except Exception as e:
            logger.warning(f"âš ï¸ éŸ³é¢‘å‚æ•°é…ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®: {e}")
            self.audio_configured = False

    def initialize(self) -> bool:
        """åˆå§‹åŒ–ASRç³»ç»Ÿ"""
        try:
            logger.info("ğŸš€ åˆå§‹åŒ–Epic1 ASRç³»ç»Ÿ...")

            # è®¾ç½®éº¦å…‹é£ - ä½¿ç”¨æ™ºèƒ½è®¾å¤‡é€‰æ‹©å™¨
            try:
                # å¯¼å…¥éŸ³é¢‘è®¾å¤‡ç®¡ç†å™¨
                from .audio_device_manager import get_device_manager, setup_16khz_recording

                logger.info("ğŸ”§ ä½¿ç”¨æ™ºèƒ½è®¾å¤‡é€‰æ‹©å™¨åˆå§‹åŒ–éº¦å…‹é£...")
                device_manager = get_device_manager()

                # è·å–æœ€ä½³è¾“å…¥è®¾å¤‡
                best_device = device_manager.get_best_input_device()
                if best_device:
                    logger.info(f"ğŸ¯ é€‰æ‹©æœ€ä½³è¾“å…¥è®¾å¤‡: {best_device.name} (ç´¢å¼•: {best_device.index})")

                    # è®¾ç½®16kHzå½•éŸ³ç¯å¢ƒ
                    setup_result = setup_16khz_recording(best_device.index)
                    if setup_result["success"]:
                        logger.info(f"âœ… 16kHzå½•éŸ³ç¯å¢ƒè®¾ç½®æˆåŠŸ: {setup_result['device_name']}")
                        logger.info(f"ğŸ“Š è®¾å¤‡ä¿¡æ¯: ç´¢å¼•={setup_result['device_index']}, é‡‡æ ·ç‡=16kHz, å£°é“=å•å£°é“")

                        # åˆå§‹åŒ–çº¿ç¨‹å®‰å…¨å½•éŸ³å™¨
                        self.audio_recorder = ThreadSafeAudioRecorder()
                        logger.info("âœ… æ™ºèƒ½éº¦å…‹é£åˆå§‹åŒ–æˆåŠŸ")
                    else:
                        logger.error(f"âŒ 16kHzå½•éŸ³ç¯å¢ƒè®¾ç½®å¤±è´¥: {setup_result.get('error', 'æœªçŸ¥é”™è¯¯')}")
                        raise Exception("16kHzç¯å¢ƒè®¾ç½®å¤±è´¥")
                else:
                    logger.error("âŒ æœªæ‰¾åˆ°å¯ç”¨çš„è¾“å…¥è®¾å¤‡")
                    raise Exception("æ— å¯ç”¨è¾“å…¥è®¾å¤‡")

            except Exception as e:
                logger.error(f"âŒ æ™ºèƒ½è®¾å¤‡é€‰æ‹©å¤±è´¥: {e}")
                # å›é€€åˆ°é»˜è®¤è®¾å¤‡é€‰æ‹©
                logger.warning("âš ï¸ å›é€€åˆ°é»˜è®¤è®¾å¤‡é€‰æ‹©...")
                try:
                    self.audio_recorder = ThreadSafeAudioRecorder()
                    logger.info("âœ… ä½¿ç”¨é»˜è®¤çº¿ç¨‹å®‰å…¨å½•éŸ³å™¨")
                except Exception as e2:
                    logger.error(f"âŒ é»˜è®¤çº¿ç¨‹å®‰å…¨å½•éŸ³å™¨åˆå§‹åŒ–ä¹Ÿå¤±è´¥: {e2}")
                    # å›é€€åˆ°ALSAå½•éŸ³å™¨
                    logger.warning("âš ï¸ å›é€€åˆ°ALSAå½•éŸ³å™¨...")
                    try:
                        from .simple_alsa_recorder import SimpleALSARecorder
                        self.audio_recorder = SimpleALSARecorder()
                        logger.info("âœ… ä½¿ç”¨ALSAå½•éŸ³å™¨")
                    except Exception as e3:
                        logger.error(f"âŒ ALSAå½•éŸ³å™¨åˆå§‹åŒ–ä¹Ÿå¤±è´¥: {e3}")
                        self.audio_recorder = None

            # åˆå§‹åŒ–ASRæœåŠ¡
            app_key = os.environ.get("ALIYUN_NLS_APPKEY", "")
            token = ""

            # ä¼˜å…ˆä½¿ç”¨å®˜æ–¹SDKè·å–Token
            if OFFICIAL_SDK_AVAILABLE:
                try:
                    access_key_id = os.environ.get("ALIBABA_CLOUD_ACCESS_KEY_ID", "")
                    access_key_secret = os.environ.get("ALIBABA_CLOUD_ACCESS_KEY_SECRET", "")

                    if access_key_id and access_key_secret:
                        token = getToken(access_key_id, access_key_secret)
                        if token:
                            logger.info("âœ… Tokenè·å–æˆåŠŸ (ä½¿ç”¨å®˜æ–¹SDK)")
                        else:
                            logger.error("âŒ å®˜æ–¹SDKè·å–Tokenå¤±è´¥")
                    else:
                        logger.error("âŒ é˜¿é‡Œäº‘è®¿é—®å¯†é’¥æœªè®¾ç½®")
                except Exception as e:
                    logger.error(f"âŒ å®˜æ–¹SDKè·å–Tokenå¼‚å¸¸: {e}")

            # å¤‡ç”¨ï¼šTokenç®¡ç†å™¨
            elif 'TOKEN_MANAGER_AVAILABLE' in locals() and TOKEN_MANAGER_AVAILABLE:
                try:
                    token_manager = get_token_manager()
                    token = token_manager.get_token()
                    if token:
                        logger.info("âœ… Tokenè·å–æˆåŠŸ (ä½¿ç”¨Tokenç®¡ç†å™¨)")
                    else:
                        logger.warning("âš ï¸ Tokenç®¡ç†å™¨è·å–å¤±è´¥")
                except Exception as e:
                    logger.warning(f"âš ï¸ Tokenç®¡ç†å™¨å¼‚å¸¸: {e}")

            # ä½¿ç”¨WebSocket ASRæœåŠ¡ï¼ˆæ ¹æ®æ¶æ„æ–‡æ¡£è¦æ±‚ï¼‰
            try:
                self.asr_service = AliyunASRWebSocketService()
                logger.info("âœ… WebSocket ASRæœåŠ¡åˆå§‹åŒ–æˆåŠŸ")
            except Exception as e:
                logger.error(f"âŒ WebSocket ASRæœåŠ¡åˆå§‹åŒ–å¤±è´¥: {e}")
                self.asr_service = None

            # åˆå§‹åŒ–å”¤é†’è¯æ£€æµ‹å™¨
            self.wake_word_detector = WakeWordDetector()
            logger.info("âœ… å”¤é†’è¯æ£€æµ‹å™¨åˆå§‹åŒ–æˆåŠŸ")

            # åˆå§‹åŒ–TTSæœåŠ¡
            try:
                # åŠ¨æ€å¯¼å…¥TTSå¼•æ“ï¼Œé¿å…å¯¼å…¥é—®é¢˜
                from modules.tts.engine.aliyun_tts_engine import AliyunTTSEngine

                tts_config = {
                    'access_key_id': os.environ.get("ALIBABA_CLOUD_ACCESS_KEY_ID", ""),
                    'access_key_secret': os.environ.get("ALIBABA_CLOUD_ACCESS_KEY_SECRET", ""),
                    'app_key': app_key,
                    'region': 'cn-shanghai',
                    'voice': 'jiajia',  # ç²¤è¯­éŸ³è‰²ï¼ˆä¸é˜¿é‡Œäº‘æ§åˆ¶å°ä¸€è‡´ï¼‰
                    'format': 'wav'
                }
                self.tts_client = AliyunTTSEngine(config=tts_config)
                logger.info("âœ… TTSæœåŠ¡åˆå§‹åŒ–æˆåŠŸ")
            except Exception as e:
                logger.warning(f"âš ï¸ TTSæœåŠ¡åˆå§‹åŒ–å¤±è´¥: {e}")
                self.tts_client = None

            # åˆå§‹åŒ–å¤šæ¨¡æ€LLM (å»¶è¿Ÿå¯¼å…¥ä»¥é¿å…ROS2ä¾èµ–)
            try:
                # åŠ¨æ€å¯¼å…¥å¤šæ¨¡æ€LLMï¼Œé¿å…é€šè¿‡LLMæ¨¡å—çš„__init__.py
                import sys
                from pathlib import Path
                llm_path = Path(__file__).parent.parent.parent / "modules" / "llm" / "qwen_multimodal_llm.py"
                if llm_path.exists():
                    sys.path.insert(0, str(llm_path.parent))
                    from qwen_multimodal_llm import QwenMultimodalLLM
                    self.llm_client = QwenMultimodalLLM()

                    if asyncio.iscoroutinefunction(self.llm_client.initialize):
                        # å¼‚æ­¥åˆå§‹åŒ–
                        loop = asyncio.get_event_loop()
                        if loop.is_running():
                            # å¦‚æœå·²åœ¨äº‹ä»¶å¾ªç¯ä¸­ï¼Œåˆ›å»ºä»»åŠ¡
                            asyncio.create_task(self._async_init_llm())
                        else:
                            # å¦‚æœæ²¡æœ‰äº‹ä»¶å¾ªç¯ï¼Œè¿è¡Œç›´åˆ°å®Œæˆ
                            loop.run_until_complete(self._async_init_llm())
                    else:
                        # åŒæ­¥åˆå§‹åŒ–
                        if self.llm_client.initialize():
                            logger.info("âœ… å¤šæ¨¡æ€LLMåˆå§‹åŒ–æˆåŠŸ")
                        else:
                            logger.warning("âš ï¸ å¤šæ¨¡æ€LLMåˆå§‹åŒ–å¤±è´¥ï¼Œä½¿ç”¨åŸºç¡€å›å¤æ¨¡å¼")
                            self.llm_client = None
                else:
                    logger.warning(f"âš ï¸ å¤šæ¨¡æ€LLMæ–‡ä»¶ä¸å­˜åœ¨: {llm_path}")
                    self.llm_client = None
            except Exception as e:
                logger.warning(f"âš ï¸ å¤šæ¨¡æ€LLMåˆå§‹åŒ–å¼‚å¸¸: {e}")
                self.llm_client = None

        except Exception as e:
            logger.error(f"âŒ ASRç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥: {e}")
            self.initialized = False
            return False

        logger.info("ğŸ‰ ASRç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼")
        self.initialized = True
        return True

    async def _async_init_llm(self):
        """å¼‚æ­¥åˆå§‹åŒ–LLM"""
        try:
            if await self.llm_client.initialize():
                logger.info("âœ… å¤šæ¨¡æ€LLMåˆå§‹åŒ–æˆåŠŸ")
            else:
                logger.warning("âš ï¸ å¤šæ¨¡æ€LLMåˆå§‹åŒ–å¤±è´¥ï¼Œä½¿ç”¨åŸºç¡€å›å¤æ¨¡å¼")
                self.llm_client = None
        except Exception as e:
            logger.warning(f"âš ï¸ å¤šæ¨¡æ€LLMåˆå§‹åŒ–å¼‚å¸¸: {e}")
            self.llm_client = None

    def start(self) -> bool:
        """å¯åŠ¨ASRç³»ç»Ÿ"""
        if self.is_running:
            logger.warning("âš ï¸ ASRç³»ç»Ÿå·²åœ¨è¿è¡Œ")
            return True

        try:
            logger.info("ğŸ¤ å¯åŠ¨è¯­éŸ³äº¤äº’æœåŠ¡...")
            self.is_running = True
            self._start_time = time.time()

            # åˆå§‹åŒ–çº¿ç¨‹å’Œäº‹ä»¶å¾ªç¯
            self._stop_event = threading.Event()
            self._listening_thread = None

            # ç³»ç»Ÿå¯åŠ¨åè¿›å…¥é™é»˜ç›‘å¬æ¨¡å¼ï¼Œç­‰å¾…å”¤é†’è¯
            logger.info("ğŸ¯ ç³»ç»Ÿå·²å¯åŠ¨ï¼Œè¿›å…¥é™é»˜ç›‘å¬æ¨¡å¼ï¼Œç­‰å¾…å”¤é†’è¯ 'å‚»å¼º'...")

            # åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­å¯åŠ¨ç›‘å¬å¾ªç¯
            self._start_listening_thread()

            logger.info("âœ… ASRç³»ç»Ÿå¯åŠ¨æˆåŠŸï¼Œå¼€å§‹ç›‘å¬...")
            return True

        except Exception as e:
            logger.error(f"âŒ ASRç³»ç»Ÿå¯åŠ¨å¤±è´¥: {e}")
            self.is_running = False
            return False

    def _start_listening_thread(self):
        """å¯åŠ¨ç›‘å¬çº¿ç¨‹"""
        def run_event_loop():
            """åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡Œäº‹ä»¶å¾ªç¯å’Œç›‘å¬å¾ªç¯"""
            try:
                # åˆ›å»ºæ–°çš„äº‹ä»¶å¾ªç¯
                loop = asyncio.new_event_loop()
                asyncio.set_event_loop(loop)

                logger.info("ğŸ”„ ç›‘å¬çº¿ç¨‹äº‹ä»¶å¾ªç¯å·²å¯åŠ¨")

                # è¿è¡Œç›‘å¬å¾ªç¯
                loop.run_until_complete(self._listening_loop())

            except Exception as e:
                logger.error(f"âŒ ç›‘å¬çº¿ç¨‹é”™è¯¯: {e}")
            finally:
                logger.info("â¹ï¸ ç›‘å¬çº¿ç¨‹å·²åœæ­¢")

        # å¯åŠ¨å®ˆæŠ¤çº¿ç¨‹
        self._listening_thread = threading.Thread(
            target=run_event_loop,
            name="ASRListeningThread",
            daemon=True
        )
        self._listening_thread.start()
        logger.info("ğŸ§µ ç›‘å¬çº¿ç¨‹å·²å¯åŠ¨")

    def start_listening(self) -> bool:
        """å¯åŠ¨ç›‘å¬ï¼ˆå…¼å®¹å¯åŠ¨è„šæœ¬è°ƒç”¨ï¼‰"""
        return self.start()

    def stop_listening(self):
        """åœæ­¢ç›‘å¬"""
        self.stop()

    def cleanup(self):
        """æ¸…ç†èµ„æº"""
        self.stop()

    def get_status(self) -> Dict[str, Any]:
        """è·å–ç³»ç»ŸçŠ¶æ€"""
        import time
        uptime_seconds = 0
        if hasattr(self, '_start_time'):
            uptime_seconds = int(time.time() - self._start_time)

        return {
            "state": "running" if self.is_running else "stopped",
            "asr_state": self.state.value,  # æ·»åŠ ASRçŠ¶æ€
            "uptime_seconds": uptime_seconds,
            "audio_recorder_available": self.audio_recorder is not None,
          "recorder_state": self.audio_recorder.get_state().value if self.audio_recorder else "unknown",
            "stats": {
                "total_listens": getattr(self, '_total_listens', 0),
                "wake_detections": getattr(self, '_wake_detections', 0),
                "successful_recognitions": getattr(self, '_successful_recognitions', 0)
            }
        }

    async def _listening_loop(self):
        """è¯­éŸ³ç›‘å¬å¾ªç¯"""
        logger.info("ğŸ¯ å¼€å§‹ç›‘å¬å”¤é†’è¯...")
        logger.info(f"ğŸ¤– åˆå§‹çŠ¶æ€: {self.state.value}")

        # åˆå§‹åŒ–ç»Ÿè®¡è®¡æ•°å™¨
        self._total_listens = 0
        self._wake_detections = 0
        self._successful_recognitions = 0

        # å¯åŠ¨å”¤é†’è¯æ£€æµ‹å™¨
        if self.wake_word_detector:
            await self.wake_word_detector.start_listening()

        try:
            while self.is_running:
                # æ£€æŸ¥åœæ­¢äº‹ä»¶
                if hasattr(self, '_stop_event') and self._stop_event.is_set():
                    logger.info("â¹ï¸ æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œé€€å‡ºç›‘å¬å¾ªç¯")
                    break

                self._total_listens += 1

                # æ¯éš”ä¸€æ®µæ—¶é—´æ‰“å°ç›‘å¬çŠ¶æ€
                if self._total_listens % 20 == 1:  # æ¯20æ¬¡ç›‘å¬æ‰“å°ä¸€æ¬¡
                    logger.info(f"ğŸ¯ ç›‘å¬è¿›è¡Œä¸­... (ç¬¬{self._total_listens}æ¬¡)")

                # ä½¿ç”¨asyncio.wait_foræ·»åŠ è¶…æ—¶ï¼Œä»¥ä¾¿å®šæœŸæ£€æŸ¥åœæ­¢äº‹ä»¶
                try:
                    # æŒç»­ç›‘å¬éŸ³é¢‘ï¼ˆå¸¦è¶…æ—¶ï¼‰
                    audio_data = await asyncio.wait_for(
                        self._listen_for_audio(),
                        timeout=3.0  # 3ç§’è¶…æ—¶ï¼Œç»™ç”¨æˆ·è¶³å¤Ÿæ—¶é—´è¯´è¯
                    )
                except asyncio.TimeoutError:
                    # è¶…æ—¶äº†ï¼Œç»§ç»­ä¸‹ä¸€è½®å¾ªç¯ä»¥æ£€æŸ¥åœæ­¢äº‹ä»¶
                    continue

                if audio_data:
                    logger.debug("ğŸ¤ æ£€æµ‹åˆ°éŸ³é¢‘è¾“å…¥ï¼Œæ£€æŸ¥å”¤é†’è¯...")

                    # æ£€æŸ¥æ˜¯å¦åŒ…å«å”¤é†’è¯
                    if await self._check_wake_word(audio_data):
                        self._wake_detections += 1
                        logger.info("ğŸ”” æ£€æµ‹åˆ°å”¤é†’è¯ï¼šå‚»å¼º")

                        # çŠ¶æ€è½¬æ¢: IDLE -> WAKE_DETECTED
                        self.state = ASRState.WAKE_DETECTED

                        # æ’­æ”¾æ¬¢è¿è¯­ï¼ˆè€Œéç¡®è®¤éŸ³ï¼‰
                        logger.info("ğŸ”Š æ’­æ”¾æ¬¢è¿è¯­...")
                        self.play_response("å‚»å¼ºç³»åº¦,è€ç»†æœ‰ä¹œå¯ä»¥å¸®åˆ°ä½ !")

                        # ç­‰å¾…æ’­æ”¾å®Œæˆï¼ˆä¼˜åŒ–ï¼šå‡å°‘ç­‰å¾…æ—¶é—´ï¼‰
                        await asyncio.sleep(1)

                        # çŠ¶æ€è½¬æ¢: WAKE_DETECTED -> LISTENING_COMMAND
                        self.state = ASRState.LISTENING_COMMAND

                        # é‡æ–°ç›‘å¬ç”¨æˆ·æŒ‡ä»¤ï¼ˆæ–°éŸ³é¢‘ï¼ï¼‰
                        command_audio = await self._listen_for_command(timeout=5.0)

                        if command_audio:
                            # çŠ¶æ€è½¬æ¢: LISTENING_COMMAND -> PROCESSING
                            self.state = ASRState.PROCESSING

                            # è¯†åˆ«ç”¨æˆ·æŒ‡ä»¤
                            text = await self._recognize_speech_from_audio(command_audio)
                            if text:
                                self._successful_recognitions += 1
                                logger.info(f"ğŸ“ è¯†åˆ«ç»“æœ: {text}")

                                # æ–°å¢ï¼šè§¦å‘å›è°ƒ - åˆ›å»ºç»“æœå¯¹è±¡å¹¶ä¼ é€’ç»™å›è°ƒå‡½æ•°
                                if self.result_callback:
                                    try:
                                        # åˆ›å»ºç®€å•çš„ç»“æœå¯¹è±¡
                                        class ASRResult:
                                            def __init__(self, text, success=True, confidence=1.0, error=None):
                                                self.text = text
                                                self.success = success
                                                self.confidence = confidence
                                                self.error = error

                                        result_obj = ASRResult(text=text, success=True, confidence=0.9)
                                        self.result_callback(result_obj)  # è§¦å‘å›è°ƒ
                                    except Exception as e:
                                        logger.error(f"âŒ ç»“æœå›è°ƒå¤±è´¥: {e}")

                                # å¤„ç†å›å¤
                                response = await self._process_command(text)
                                if response:
                                    logger.info(f"ğŸ”Š å›å¤: {response}")

                                    # çŠ¶æ€è½¬æ¢: PROCESSING -> RESPONDING
                                    self.state = ASRState.RESPONDING

                                    self.play_response(response)
                            else:
                                logger.warning("âš ï¸ è¯­éŸ³è¯†åˆ«å¤±è´¥")

                                # æ–°å¢ï¼šè§¦å‘å¤±è´¥å›è°ƒ
                                if self.result_callback:
                                    try:
                                        class ASRResult:
                                            def __init__(self, text, success=True, confidence=1.0, error=None):
                                                self.text = text
                                                self.success = success
                                                self.confidence = confidence
                                                self.error = error

                                        result_obj = ASRResult(text="", success=False, confidence=0.0, error="è¯­éŸ³è¯†åˆ«å¤±è´¥")
                                        self.result_callback(result_obj)  # è§¦å‘å›è°ƒ
                                    except Exception as e:
                                        logger.error(f"âŒ ç»“æœå›è°ƒå¤±è´¥: {e}")
                        else:
                            logger.warning("âš ï¸ æœªæ£€æµ‹åˆ°ç”¨æˆ·æŒ‡ä»¤ï¼Œè¶…æ—¶è¿”å›ç›‘å¬æ¨¡å¼")

                        # çŠ¶æ€è½¬æ¢: è¿”å› IDLE
                        self.state = ASRState.IDLE
                        logger.info("ğŸ”„ è¿”å›ç©ºé—²ç›‘å¬æ¨¡å¼")

                # çŸ­æš‚ä¼‘æ¯ï¼Œé¿å…CPUå ç”¨è¿‡é«˜
                await asyncio.sleep(0.1)

        except Exception as e:
            logger.error(f"âŒ ç›‘å¬å¾ªç¯å¼‚å¸¸: {e}")
        finally:
            # åœæ­¢å”¤é†’è¯æ£€æµ‹å™¨
            if self.wake_word_detector:
                await self.wake_word_detector.stop_listening()
            logger.info("ğŸ ç›‘å¬å¾ªç¯å·²ç»“æŸ")

    async def _listen_for_audio(self) -> Optional[np.ndarray]:
        """ç›‘å¬éŸ³é¢‘è¾“å…¥ - ä½¿ç”¨çº¿ç¨‹å®‰å…¨å½•éŸ³å™¨"""
        if not self.audio_recorder:
            logger.warning("âš ï¸ å½•éŸ³å™¨æœªåˆå§‹åŒ–ï¼Œæ¨¡æ‹Ÿç›‘å¬...")
            # æ¨¡æ‹Ÿç›‘å¬ - è¿”å›Noneè¡¨ç¤ºæ²¡æœ‰éŸ³é¢‘
            await asyncio.sleep(0.1)
            return None

        try:
            # æ£€æŸ¥å½•éŸ³å™¨çŠ¶æ€ï¼Œé¿å…æ— æ•ˆè°ƒç”¨
            recorder_state = self.audio_recorder.get_state()
            if recorder_state.name != 'IDLE':
                logger.debug(f"å½•éŸ³å™¨å¿™ç¢Œï¼Œè·³è¿‡æœ¬æ¬¡ç›‘å¬: {recorder_state.value}")
                await asyncio.sleep(0.1)
                return None

            # å¯åŠ¨å½•éŸ³
            logger.debug("ğŸ¤ å¼€å§‹éŸ³é¢‘ç›‘å¬...")
            success = self.audio_recorder.start_recording(duration=5.0)

            if not success:
                logger.debug("âš ï¸ å½•éŸ³å¯åŠ¨å¤±è´¥")
                return None

            # ä½¿ç”¨äº‹ä»¶ç­‰å¾…æœºåˆ¶ï¼Œè€Œéå›ºå®šsleep
            completion_event = self.audio_recorder.get_completion_event()
            try:
                await asyncio.wait_for(
                    asyncio.to_thread(completion_event.wait),
                    timeout=6.0
                )
                logger.debug("âœ… å½•éŸ³å®Œæˆäº‹ä»¶è§¦å‘")
            except asyncio.TimeoutError:
                logger.warning("â° å½•éŸ³è¶…æ—¶ï¼Œå¼ºåˆ¶åœæ­¢")
                if self.audio_recorder.get_state() == RecordingState.RECORDING:
                    self.audio_recorder.force_stop()

            # è·å–éŸ³é¢‘æ•°æ®
            audio_data = self.audio_recorder.stop_recording()

            if len(audio_data) > 0:
                logger.debug(f"ğŸ¤ æˆåŠŸæ•è·éŸ³é¢‘ç‰‡æ®µ: {len(audio_data)} samples")
                return audio_data
            else:
                logger.debug("â° å½•éŸ³å®Œæˆä½†æ— éŸ³é¢‘æ•°æ®")
                return None

        except Exception as e:
            logger.error(f"âŒ éŸ³é¢‘ç›‘å¬å¤±è´¥: {type(e).__name__}: {e}")
            # å¦‚æœç›‘å¬å¤±è´¥ï¼Œè¿”å›Noneè®©å¾ªç¯ç»§ç»­
            return None

    async def _listen_for_command(self, timeout: float = 5.0) -> Optional[np.ndarray]:
        """
        ç›‘å¬ç”¨æˆ·å‘½ä»¤ï¼ˆå”¤é†’åï¼‰- ä½¿ç”¨ThreadSafeAudioRecorder

        Args:
            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰

        Returns:
            éŸ³é¢‘æ•°æ®æˆ–None
        """
        if not self.audio_recorder:
            logger.error("âŒ ThreadSafeAudioRecorderæœªåˆå§‹åŒ–")
            return None

        try:
            logger.info(f"ğŸ¤ ç­‰å¾…ç”¨æˆ·æŒ‡ä»¤ï¼ˆè¶…æ—¶{timeout}ç§’ï¼‰...")

            # ä½¿ç”¨ThreadSafeAudioRecorderå½•éŸ³ï¼Œæ—¶é•¿ä¸ºè¶…æ—¶æ—¶é—´
            duration = min(timeout, 10.0)  # æœ€å¤š10ç§’
            success = self.audio_recorder.start_recording(duration=duration)

            if not success:
                current_state = self.audio_recorder.get_state()
                logger.warning(f"âš ï¸ å‘½ä»¤å½•éŸ³å¯åŠ¨å¤±è´¥ï¼Œå½“å‰çŠ¶æ€: {current_state.value}")
                return None

            # ä½¿ç”¨äº‹ä»¶ç­‰å¾…æœºåˆ¶ï¼Œè€Œéå›ºå®šsleep
            completion_event = self.audio_recorder.get_completion_event()
            try:
                await asyncio.wait_for(
                    asyncio.to_thread(completion_event.wait),
                    timeout=duration + 2.0  # é¢å¤–2ç§’ç¼“å†²
                )
                logger.debug("âœ… å‘½ä»¤å½•éŸ³å®Œæˆäº‹ä»¶è§¦å‘")
            except asyncio.TimeoutError:
                logger.warning("â° å‘½ä»¤å½•éŸ³è¶…æ—¶ï¼Œå¼ºåˆ¶åœæ­¢")
                if self.audio_recorder.get_state() == RecordingState.RECORDING:
                    self.audio_recorder.force_stop()

            # åœæ­¢å½•éŸ³å¹¶è·å–éŸ³é¢‘æ•°æ®
            audio_data = self.audio_recorder.stop_recording()

            if len(audio_data) > 0:
                logger.info("âœ… æ•è·åˆ°ç”¨æˆ·æŒ‡ä»¤éŸ³é¢‘")
                return audio_data
            else:
                logger.info("â° å½•éŸ³å®Œæˆï¼Œä½†æ— éŸ³é¢‘æ•°æ®")
                return None

        except Exception as e:
            logger.error(f"âŒ ç›‘å¬ç”¨æˆ·æŒ‡ä»¤å¤±è´¥: {type(e).__name__}: {e}")
            return None

    async def _check_wake_word(self, audio_data: np.ndarray) -> bool:
        """æ£€æŸ¥éŸ³é¢‘ä¸­æ˜¯å¦åŒ…å«å”¤é†’è¯ - ä¼˜å…ˆä½¿ç”¨é˜¿é‡Œäº‘ASR"""
        try:
            # æ£€æŸ¥å†·å´æ—¶é—´ï¼Œé¿å…é‡å¤æ£€æµ‹
            current_time = time.time()
            if current_time - self.last_wake_time < self.wake_cooldown:
                return False

            wake_word_detected = False

            # æ–¹æ³•1: ä¼˜å…ˆä½¿ç”¨WebSocket ASRï¼ˆæ ¹æ®æ¶æ„æ–‡æ¡£è¦æ±‚ï¼‰
            if self.asr_service:
                try:
                    # ä¿å­˜éŸ³é¢‘åˆ°ä¸´æ—¶æ–‡ä»¶
                    wav_data = audio_data.get_wav_data()
                    temp_file = tempfile.NamedTemporaryFile(suffix='.wav', delete=False)
                    temp_file.write(wav_data)
                    temp_file.close()

                    # ä½¿ç”¨WebSocket ASRæœåŠ¡
                    result = self.asr_service.recognize_audio(temp_file.name)

                    # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
                    os.unlink(temp_file.name)

                    if result and result.text:
                        text = result.text.strip().lower()
                        logger.info(f"ğŸ” WebSocket ASRè¯†åˆ«æ–‡æœ¬: {text}")

                        # ç²¤è¯­å”¤é†’è¯æ£€æµ‹ï¼ˆä¸¥æ ¼ç™½åå•ï¼Œé¿å…è¯¯è¯†åˆ«ï¼‰
                        wake_words = [
                            "å‚»å¼º", "å‚»å¼ºå•Š", "å‚»å¼ºå‘€", "å‚»å¼·", "å‚»å¼·å•Š", "å‚»å¼·å‘€"
                        ]

                        for wake_word in wake_words:
                            if wake_word in text:
                                logger.info(f"âœ… WebSocketæ£€æµ‹åˆ°å”¤é†’è¯: {wake_word} (åŸæ–‡: {text})")
                                wake_word_detected = True
                                self.last_wake_time = current_time
                                return True

                except Exception as e:
                    logger.debug(f"âš ï¸ é˜¿é‡Œäº‘ASRè¯†åˆ«å¼‚å¸¸: {e}")

            # å¦‚æœé˜¿é‡Œäº‘ASRæ²¡æœ‰æ£€æµ‹åˆ°å”¤é†’è¯ï¼Œç›´æ¥è¿”å›False
            logger.debug("âŒ é˜¿é‡Œäº‘ASRæœªæ£€æµ‹åˆ°å”¤é†’è¯")
            return False

        except Exception as e:
            logger.error(f"âŒ å”¤é†’è¯æ£€æµ‹å¼‚å¸¸: {e}")
            return False

    async def _play_wake_confirmation(self):
        """æ’­æ”¾å”¤é†’ç¡®è®¤éŸ³ï¼ˆå·²åºŸå¼ƒï¼Œç°åœ¨ç›´æ¥æ’­æ”¾æ¬¢è¿è¯­ï¼‰"""
        # æ­¤æ–¹æ³•å·²åºŸå¼ƒï¼Œç°åœ¨åœ¨æ£€æµ‹åˆ°å”¤é†’è¯åç›´æ¥æ’­æ”¾å®Œæ•´çš„æ¬¢è¿è¯­
        logger.debug("å”¤é†’ç¡®è®¤éŸ³åŠŸèƒ½å·²æ•´åˆåˆ°æ¬¢è¿è¯­æ’­æ”¾ä¸­")
        pass

    async def _recognize_speech_from_audio(self, audio_data: np.ndarray) -> Optional[str]:
        """ä»éŸ³é¢‘æ•°æ®è¿›è¡Œè¯­éŸ³è¯†åˆ«"""
        if not self.asr_service:
            logger.error("âŒ ASRæœåŠ¡æœªåˆå§‹åŒ–")
            return None

        try:
            # å°†AudioDataè½¬æ¢ä¸ºWAVæ ¼å¼çš„å­—èŠ‚æ•°æ®
            wav_data = audio_data.get_wav_data()

            # è°ƒç”¨é˜¿é‡Œäº‘ASRæœåŠ¡è¿›è¡Œè¯†åˆ«
            result = self._call_aliyun_asr(wav_data)

            if result and result.strip():
                logger.info(f"ğŸ¯ é˜¿é‡Œäº‘ASRè¯†åˆ«ç»“æœ: {result}")
                return result
            else:
                # Fallbackåˆ°æœ¬åœ°è¯†åˆ«
                return self._fallback_local_recognition(audio_data)

        except Exception as e:
            logger.error(f"âŒ é˜¿é‡Œäº‘ASRè¯†åˆ«å¤±è´¥: {e}")
            # å°è¯•æœ¬åœ°fallback
            return self._fallback_local_recognition(audio_data)

    def _call_aliyun_asr(self, wav_data: bytes) -> Optional[str]:
        """è°ƒç”¨é˜¿é‡Œäº‘ASRæœåŠ¡ - WebSocketç‰ˆæœ¬"""
        try:
            if not self.asr_service:
                logger.error("âŒ ASRæœåŠ¡æœªåˆå§‹åŒ–")
                return None

            logger.info("ğŸ” è°ƒç”¨é˜¿é‡Œäº‘ASR WebSocketæœåŠ¡è¿›è¡Œè¯†åˆ«...")

            # ä¿å­˜éŸ³é¢‘æ•°æ®åˆ°ä¸´æ—¶æ–‡ä»¶ï¼ˆWebSocket APIéœ€è¦æ–‡ä»¶è·¯å¾„ï¼‰
            import tempfile
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                temp_file.write(wav_data)
                temp_file_path = temp_file.name

            try:
                # è°ƒç”¨WebSocket ASRæœåŠ¡
                result = self.asr_service.recognize_file(
                    audio_file_path=temp_file_path,
                    language="cn-cantonese",
                    format="wav"
                )

                # WebSocket APIè¿”å›ç›´æ¥æ–‡æœ¬ç»“æœ
                if result and result.strip():
                    logger.info(f"âœ… é˜¿é‡Œäº‘ASR WebSocketè¯†åˆ«æˆåŠŸ: {result}")
                    return result
                else:
                    logger.warning("âš ï¸ é˜¿é‡Œäº‘ASR WebSocketè¯†åˆ«è¿”å›ç©ºç»“æœ")
                    return None

            finally:
                # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
                import os
                try:
                    os.unlink(temp_file_path)
                except:
                    pass

        except Exception as e:
            logger.error(f"âŒ é˜¿é‡Œäº‘ASR WebSocketè°ƒç”¨å¤±è´¥: {e}")
            return None

    def _fallback_local_recognition(self, audio_data: np.ndarray) -> Optional[str]:
        """æœ¬åœ°è¯­éŸ³è¯†åˆ«ä½œä¸ºfallback - å·²ç¦ç”¨ï¼Œä½¿ç”¨ThreadSafeAudioRecorder"""
        # TODO: å®ç°åŸºäºThreadSafeAudioRecorderçš„æœ¬åœ°è¯†åˆ«
        logger.warning("âš ï¸ æœ¬åœ°è¯†åˆ«åŠŸèƒ½æš‚æ—¶ç¦ç”¨ï¼Œä½¿ç”¨ä¸»è¦ASRæœåŠ¡")
        return None

    async def _recognize_speech(self) -> Optional[str]:
        """è¯­éŸ³è¯†åˆ«ï¼ˆå…¼å®¹æ—§æ¥å£ï¼‰"""
        try:
            # ç›‘å¬éŸ³é¢‘å¹¶è¿›è¡Œè¯†åˆ«
            audio_data = await self._listen_for_audio()
            if audio_data:
                return await self._recognize_speech_from_audio(audio_data)
            return None
        except Exception as e:
            logger.error(f"è¯­éŸ³è¯†åˆ«å¤±è´¥: {e}")
            return None

    async def _process_command(self, text: str) -> Optional[str]:
        """å¤„ç†è¯­éŸ³å‘½ä»¤ - ä½¿ç”¨å¤šæ¨¡æ€LLM"""
        try:
            if not self.llm_client:
                # å¦‚æœLLMä¸å¯ç”¨ï¼Œä½¿ç”¨åŸºç¡€å›å¤
                return await self._basic_command_response(text)

            # æ·»åŠ å¯¹è¯å†å²
            self.conversation_history.append({
                "role": "user",
                "content": text
            })

            # é™åˆ¶å†å²é•¿åº¦
            if len(self.conversation_history) > self.max_history_length:
                self.conversation_history = self.conversation_history[-self.max_history_length:]

            # ä½¿ç”¨å¤šæ¨¡æ€LLMå¤„ç†
            response = await self.llm_client.process_voice_command(
                text=text,
                previous_context=self.conversation_history[:-1]  # æ’é™¤å½“å‰ç”¨æˆ·æ¶ˆæ¯
            )

            # æ·»åŠ åŠ©æ‰‹å›å¤åˆ°å†å²
            if response:
                self.conversation_history.append({
                    "role": "assistant",
                    "content": response
                })

                logger.info(f"ğŸ¤– LLMå¤„ç†: {text[:30]}... -> {response[:50]}...")
                return response
            else:
                return "æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œè¯·ç¨åå†è¯•ã€‚"

        except Exception as e:
            logger.error(f"âŒ LLMå‘½ä»¤å¤„ç†å¤±è´¥: {e}")
            return "ç³»ç»Ÿé‡åˆ°é—®é¢˜ï¼Œè¯·ç¨åå†è¯•ã€‚"

    async def _basic_command_response(self, text: str) -> Optional[str]:
        """åŸºç¡€å‘½ä»¤å›å¤ï¼ˆLLMä¸å¯ç”¨æ—¶çš„fallbackï¼‰"""
        try:
            text_lower = text.lower()

            if "å¤©æ°”" in text_lower:
                return await self.llm_client.get_weather_response() if self.llm_client else "ä»Šæ—¥å¤©æ°”æ™´æœ—ï¼Œæ¸©åº¦é€‚å®œï¼Œé€‚åˆå‡ºè¡Œ"
            elif "æ—¶é—´" in text_lower or "å‡ æ—¶" in text_lower:
                return await self.llm_client.get_time_response() if self.llm_client else await self._get_current_time()
            elif "ä½ å¥½" in text_lower or "å“ˆå–½" in text_lower or "hello" in text_lower:
                return "ä½ å¥½ï¼æˆ‘æ˜¯å‚»å¼ºï¼Œæœ‰ä»€ä¹ˆå¯ä»¥å¸®åˆ°ä½ ï¼Ÿ"
            elif "æ‹œæ‹œ" in text_lower or "å†è§" in text_lower:
                return "æ‹œæ‹œï¼æœ‰éœ€è¦éšæ—¶å«æˆ‘å‚»å¼ºï¼"
            elif "æ„Ÿè°¢" in text_lower or "å¤šè°¢" in text_lower:
                return "ä¸å®¢æ°”ï¼è¿™æ˜¯å‚»å¼ºåº”è¯¥åšçš„ã€‚"
            else:
                return "æŠ±æ­‰ï¼Œæˆ‘æ²¡æœ‰ç†è§£æ‚¨çš„æŒ‡ä»¤ï¼Œè¯·é‡æ–°è¯´ä¸€æ¬¡ã€‚"

        except Exception as e:
            logger.error(f"âŒ åŸºç¡€å‘½ä»¤å›å¤å¤±è´¥: {e}")
            return "æŠ±æ­‰ï¼Œæˆ‘ç°åœ¨æ— æ³•å¤„ç†è¿™ä¸ªé—®é¢˜ã€‚"

    async def _get_current_time(self) -> str:
        """è·å–å½“å‰æ—¶é—´"""
        try:
            import datetime
            now = datetime.datetime.now()
            return f"ç°åœ¨æ—¶é—´æ˜¯{now.strftime('%Hç‚¹%Måˆ†')}"
        except Exception as e:
            logger.error(f"âŒ è·å–æ—¶é—´å¤±è´¥: {e}")
            return "æ— æ³•è·å–å½“å‰æ—¶é—´"

    def play_response(self, text: str):
        """æ’­æ”¾è¯­éŸ³å›å¤ - å¢å¼ºç‰ˆTTSåˆå§‹åŒ–æ£€æŸ¥"""
        try:
            # å¢å¼ºçš„TTSå®¢æˆ·ç«¯æ£€æŸ¥
            if not self.tts_client:
                logger.warning("âš ï¸ TTSå®¢æˆ·ç«¯æœªåˆå§‹åŒ–ï¼Œå°è¯•é‡æ–°åˆå§‹åŒ–...")

                # å°è¯•é‡æ–°åˆå§‹åŒ–TTS
                if self._retry_init_tts():
                    logger.info("âœ… TTSå®¢æˆ·ç«¯é‡æ–°åˆå§‹åŒ–æˆåŠŸ")
                else:
                    logger.error("âŒ TTSå®¢æˆ·ç«¯åˆå§‹åŒ–å¤±è´¥ï¼Œæ’­æ”¾å¤‡ç”¨æç¤ºéŸ³")
                    self._play_fallback_sound()
                    return False

            logger.info(f"ğŸ”Š å‡†å¤‡æ’­æ”¾å›å¤: {text}")

            # è°ƒç”¨TTSæœåŠ¡åˆæˆè¯­éŸ³
            try:
                audio_data = self.tts_client.synthesize(text)
                if audio_data:
                    logger.info(f"âœ… åˆæˆè¯­éŸ³æˆåŠŸï¼Œé•¿åº¦: {len(audio_data)}å­—èŠ‚")

                    # æ’­æ”¾éŸ³é¢‘
                    success = self._play_audio_data(audio_data)
                    if success:
                        logger.info("âœ… éŸ³é¢‘æ’­æ”¾æˆåŠŸ")
                        return True
                    else:
                        logger.warning("âš ï¸ éŸ³é¢‘æ’­æ”¾å¤±è´¥ï¼Œæ’­æ”¾å¤‡ç”¨æç¤ºéŸ³")
                        self._play_fallback_sound()
                        return False
                else:
                    logger.warning("âš ï¸ è¯­éŸ³åˆæˆå¤±è´¥ï¼Œæ’­æ”¾å¤‡ç”¨æç¤ºéŸ³")
                    self._play_fallback_sound()
                    return False

            except Exception as tts_error:
                logger.error(f"âŒ TTSåˆæˆè¿‡ç¨‹å‡ºé”™: {tts_error}")
                logger.warning("âš ï¸ æ’­æ”¾å¤‡ç”¨æç¤ºéŸ³")
                self._play_fallback_sound()
                return False

        except Exception as e:
            logger.error(f"âŒ è¯­éŸ³æ’­æ”¾å¤±è´¥: {e}")
            self._play_fallback_sound()
            return False

    def _retry_init_tts(self) -> bool:
        """é‡æ–°åˆå§‹åŒ–TTSå®¢æˆ·ç«¯"""
        try:
            # æŸ¥æ‰¾TTSé…ç½®
            from modules.tts.engine.aliyun_tts_engine import AliyunTTSEngine

            tts_config = {
                "voice": "aixiaoming",  # ç²¤è¯­éŸ³è‰²
                "rate": "0",  # æ­£å¸¸è¯­é€Ÿ
                "volume": "50",  # éŸ³é‡
                "pitch": "0",  # éŸ³è°ƒ
                "audio_format": "wav"  # éŸ³é¢‘æ ¼å¼
            }

            # å°è¯•é‡æ–°åˆå§‹åŒ–
            self.tts_client = AliyunTTSEngine(config=tts_config)

            # æµ‹è¯•TTSæ˜¯å¦æ­£å¸¸å·¥ä½œ
            test_audio = self.tts_client.synthesize("æµ‹è¯•")
            return test_audio is not None

        except Exception as e:
            logger.error(f"âŒ TTSé‡æ–°åˆå§‹åŒ–å¤±è´¥: {e}")
            self.tts_client = None
            return False

    def _play_fallback_sound(self):
        """æ’­æ”¾å¤‡ç”¨æç¤ºéŸ³ - é™é»˜æ¨¡å¼é¿å…å¹²æ‰°"""
        # é™é»˜æ¨¡å¼ï¼šä¸æ’­æ”¾æç¤ºéŸ³ï¼Œä»…è®°å½•æ—¥å¿—
        logger.warning("ğŸ“¢ TTSä¸å¯ç”¨ï¼Œè·³è¿‡è¯­éŸ³æ’­æ”¾ï¼ˆé™é»˜æ¨¡å¼ï¼‰")
        return False

        # ä»¥ä¸‹ä»£ç ä¿ç•™ç”¨äºç´§æ€¥æƒ…å†µï¼Œä½†é»˜è®¤ä¸æ‰§è¡Œ
        try:
            # å°è¯•æ’­æ”¾ç³»ç»Ÿæç¤ºéŸ³æˆ–é¢„å®šä¹‰éŸ³é¢‘æ–‡ä»¶
            fallback_paths = [
                "src/modules/asr/audio/beep.wav",
                "src/modules/asr/audio/alert.wav",
                "/usr/share/sounds/alsa/Front_Center.wav"  # Linuxç³»ç»ŸéŸ³
            ]

            for sound_path in fallback_paths:
                if os.path.exists(sound_path):
                    logger.info(f"ğŸ”Š æ’­æ”¾å¤‡ç”¨æç¤ºéŸ³: {sound_path}")
                    try:
                        import subprocess
                        subprocess.run(["aplay", sound_path], check=True, capture_output=True)
                        return True
                    except Exception as e:
                        logger.debug(f"æ’­æ”¾å¤‡ç”¨æç¤ºéŸ³å¤±è´¥ {sound_path}: {e}")
                        continue

            # å¦‚æœæ²¡æœ‰éŸ³é¢‘æ–‡ä»¶ï¼Œè¾“å‡ºåˆ°æ§åˆ¶å°
            logger.warning("ğŸ“¢ æ— å¯ç”¨éŸ³é¢‘æ–‡ä»¶ï¼Œä»…è¾“å‡ºåˆ°æ§åˆ¶å°: æç¤ºéŸ³")
            print("ğŸ”” *æç¤ºéŸ³*")

        except Exception as e:
            logger.error(f"âŒ æ’­æ”¾å¤‡ç”¨æç¤ºéŸ³å¤±è´¥: {e}")
            # æœ€åçš„å¤‡ç”¨æ–¹æ¡ˆ
            print("ğŸ”” *ç³»ç»Ÿæç¤ºéŸ³*")

    def _play_audio_data(self, audio_data: bytes) -> bool:
        """æ’­æ”¾éŸ³é¢‘æ•°æ®"""
        try:
            import pygame
            import tempfile

            # åˆå§‹åŒ–pygameéŸ³é¢‘
            pygame.mixer.init()

            # å°†éŸ³é¢‘æ•°æ®ä¿å­˜åˆ°ä¸´æ—¶æ–‡ä»¶
            with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                temp_file.write(audio_data)
                temp_file_path = temp_file.name

            try:
                # æ’­æ”¾éŸ³é¢‘æ–‡ä»¶
                pygame.mixer.music.load(temp_file_path)
                pygame.mixer.music.play()

                # ç­‰å¾…æ’­æ”¾å®Œæˆ
                while pygame.mixer.music.get_busy():
                    pygame.time.Clock().tick(10)

                return True

            finally:
                # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
                try:
                    os.unlink(temp_file_path)
                except:
                    pass
                pygame.mixer.quit()

        except ImportError:
            # å¦‚æœæ²¡æœ‰pygameï¼Œå°è¯•ä½¿ç”¨aplay (Linux)
            try:
                import tempfile
                with tempfile.NamedTemporaryFile(suffix='.wav', delete=False) as temp_file:
                    temp_file.write(audio_data)
                    temp_file_path = temp_file.name

                import subprocess
                result = subprocess.run(['aplay', temp_file_path],
                                      capture_output=True, text=True)

                os.unlink(temp_file_path)
                return result.returncode == 0

            except Exception as e:
                logger.error(f"âŒ ä½¿ç”¨aplayæ’­æ”¾å¤±è´¥: {e}")
                return False

        except Exception as e:
            logger.error(f"âŒ éŸ³é¢‘æ’­æ”¾å¤±è´¥: {e}")
            return False

    def stop(self):
        """åœæ­¢ASRç³»ç»Ÿ"""
        logger.info("ğŸ›‘ åœæ­¢ASRç³»ç»Ÿ...")

        # è®¾ç½®åœæ­¢æ ‡å¿—
        self.is_running = False

        # å‘é€åœæ­¢ä¿¡å·ç»™ç›‘å¬çº¿ç¨‹
        if hasattr(self, '_stop_event'):
            self._stop_event.set()

        # ç­‰å¾…ç›‘å¬çº¿ç¨‹ç»“æŸï¼ˆæœ€å¤šç­‰å¾…5ç§’ï¼‰
        if hasattr(self, '_listening_thread') and self._listening_thread:
            logger.info("â³ ç­‰å¾…ç›‘å¬çº¿ç¨‹åœæ­¢...")
            self._listening_thread.join(timeout=5.0)
            if self._listening_thread.is_alive():
                logger.warning("âš ï¸ ç›‘å¬çº¿ç¨‹æœªèƒ½åœ¨5ç§’å†…åœæ­¢")
            else:
                logger.info("âœ… ç›‘å¬çº¿ç¨‹å·²åœæ­¢")

        logger.info("âœ… ASRç³»ç»Ÿå·²åœæ­¢")

    def _get_access_token(self) -> str:
        """è·å–é˜¿é‡Œäº‘è®¿é—®ä»¤ç‰Œ"""
        try:
            import requests
            from datetime import datetime

            access_key_id = os.environ.get("ALIBABA_CLOUD_ACCESS_KEY_ID", "")
            access_key_secret = os.environ.get("ALIBABA_CLOUD_ACCESS_KEY_SECRET", "")

            if not access_key_id or not access_key_secret:
                logger.warning("âš ï¸ é˜¿é‡Œäº‘è®¿é—®å¯†é’¥æœªè®¾ç½®")
                return ""

            url = "https://nls-meta.cn-shanghai.aliyuncs.com/pop/2018-05-18/tokens"
            headers = {
                "Content-Type": "application/json",
                "Date": datetime.utcnow().strftime('%a, %d %b %Y %H:%M:%S GMT'),
                "Host": "nls-meta.cn-shanghai.aliyuncs.com"
            }

            data = {
                "AccessKeyId": access_key_id,
                "Action": "CreateToken"
            }

            response = requests.post(url, headers=headers, json=data, timeout=10)

            if response.status_code == 200:
                result = response.json()
                if "Token" in result and "Id" in result["Token"]:
                    token = result["Token"]["Id"]
                    logger.info(f"âœ… è·å–è®¿é—®ä»¤ç‰ŒæˆåŠŸ: {token[:20]}...")
                    return token
                else:
                    logger.error(f"âŒ Tokenå“åº”æ ¼å¼é”™è¯¯: {result}")
                    return ""
            else:
                logger.error(f"âŒ è·å–Tokenå¤±è´¥ï¼ŒçŠ¶æ€ç : {response.status_code}")
                logger.error(f"å“åº”å†…å®¹: {response.text}")
                return ""

        except Exception as e:
            logger.error(f"âŒ è·å–è®¿é—®ä»¤ç‰Œå¼‚å¸¸: {e}")
            return ""

def main():
    """ä¸»å‡½æ•°ç”¨äºæµ‹è¯•"""
    logging.basicConfig(level=logging.INFO)

    asr_system = ASRSystem()

    if asr_system.initialize():
        print("âœ… ASRç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ")
    else:
        print("âŒ ASRç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥")
        return False

    # æ¨¡æ‹Ÿå¯åŠ¨ï¼ˆæµ‹è¯•ç”¨ï¼‰
    print("ASRç³»ç»Ÿå‡†å¤‡å°±ç»ª")
    return True

if __name__ == "__main__":
    main()